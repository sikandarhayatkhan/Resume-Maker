head	1.14;
access;
symbols;
locks
	chris:1.14; strict;
comment	@# @;


1.14
date	2017.06.04.16.37.34;	author chris;	state Exp;
branches;
next	1.13;

1.13
date	2017.06.04.16.30.26;	author chris;	state Exp;
branches;
next	1.12;

1.12
date	2017.06.04.16.28.28;	author chris;	state Exp;
branches;
next	1.11;

1.11
date	2017.06.04.16.27.37;	author chris;	state Exp;
branches;
next	1.10;

1.10
date	2017.06.04.16.25.45;	author chris;	state Exp;
branches;
next	1.9;

1.9
date	2017.06.04.16.22.57;	author chris;	state Exp;
branches;
next	1.8;

1.8
date	2017.06.04.16.11.49;	author chris;	state Exp;
branches;
next	1.7;

1.7
date	2017.06.04.16.10.45;	author chris;	state Exp;
branches;
next	1.6;

1.6
date	2017.06.04.16.09.05;	author chris;	state Exp;
branches;
next	1.5;

1.5
date	2017.06.04.15.16.09;	author chris;	state Exp;
branches;
next	1.4;

1.4
date	2017.06.04.15.04.17;	author chris;	state Exp;
branches;
next	1.3;

1.3
date	2017.06.04.13.11.19;	author chris;	state Exp;
branches;
next	1.2;

1.2
date	2017.05.29.18.40.39;	author chris;	state Exp;
branches;
next	1.1;

1.1
date	2017.05.29.14.43.31;	author chris;	state Exp;
branches;
next	;


desc
@vim
@


1.14
log
@(rcsvers.vim) modified outside of vim.
@
text
@// index.js of module pug-pdf

'use strict';

var fs = require('fs'),
    path = require('path'),
    through2 = require('through2'),
    pug = require('pug'),
    tmp = require('tmp'),
    childProcess = require('child_process'),
    duplexer = require('duplexer');

tmp.setGracefulCleanup();

function pugpdf (options) {
    options = options || {};
    options.phantomPath = options.phantomPath || require('phantomjs-prebuilt').path;
    options.cssPath = options.cssPath || __dirname + '/../pdf.css';
    options.paperFormat = options.paperFormat || 'A4';
    options.paperOrientation = options.paperOrientation || 'portrait';
    options.paperBorder = options.paperBorder || '1cm';
    options.locals = options.locals || {};

    var pugStr = '';
    var pugToHtml = through2(
        function write (chunk, enc, cb) {
            //console.log('pugToHtml chunk:', chunk.toString());
            pugStr += chunk.toString(); // accumulate whole pug template
            cb();
        },
        function end (cb) {
            //var fn = pug.compile(pugStr);
            //console.log('pugToHtml whole template:', pugStr);
            try {
                const html = pug.render(pugStr, options.locals);
                //console.log('pugToHtml html:', html);
                this.push(html);
            } catch (err) {
                //console.log('pugToHtml error: ', err);
                const error_html = `<!DOCTYPE html><html><body><h1>Error rendering Pug template</h1><pre>${err.message}</pre></body></html>`;
                this.push(error_html);
            }
            cb();
        }
    );
//    pugToHtml.on('error', (err) => {
//        console.log('=== pugToHtml error: ', err);
//    });

    const inputStream = through2(),
        outputStream = through2();

    inputStream.pause(); // until we are ready to read

    tmp.file({postfix: '.html'}, function(err, tmpHtmlPath, tmpHtmlFd) {
        if (err) {
            return outputStream.emit('error', err);
        }
        fs.close(tmpHtmlFd);

        tmp.file({postfix: '.pdf'}, function(err, tmpPdfPath, tmpPdfFd) {
            if (err) {
                return outputStream.emit('error', err);
            }
            fs.close(tmpPdfFd);

            var htmlToTmpHtmlFile = fs.createWriteStream(tmpHtmlPath);
            htmlToTmpHtmlFile.on('finish', function() {
                var args = [
                    path.join(__dirname, 'phantom-script.js'),
                    tmpHtmlPath,
                    tmpPdfPath,
                    options.cssPath,
                    options.paperFormat,
                    options.paperOrientation,
                    options.paperBorder,
                ];

                childProcess.execFile(options.phantomPath, args, function(err, stdout, stderr) {
                    if (err) {
                        return outputStream.emit('error', err);
                    }
                    fs.createReadStream(tmpPdfPath).pipe(outputStream);
                });
            });

            inputStream.pipe(pugToHtml).pipe(htmlToTmpHtmlFile);
            inputStream.resume();
        });
    });

    return duplexer(inputStream, outputStream);
}

module.exports = pugpdf;
@


1.13
log
@(rcsvers.vim) modified outside of vim.
@
text
@d27 1
a27 1
            console.log('pugToHtml chunk:', chunk.toString());
d33 1
a33 1
            console.log('pugToHtml whole template:', pugStr);
d36 1
a36 1
                console.log('pugToHtml html:', html);
d43 1
a43 2
            //this.queue(html);
            //this.queue(null);
d46 3
a48 3
    pugToHtml.on('error', (err) => {
        console.log('=== pugToHtml error: ', err);
    });
@


1.12
log
@(rcsvers.vim) modified outside of vim.
@
text
@d39 2
a40 2
                console.log('pugToHtml error: ', err);
                const error_html = `<doctype html><html><body><h1>Error rendering Pug template</h1><pre>${err.message}</pre></body></html>`;
@


1.11
log
@(rcsvers.vim) modified outside of vim.
@
text
@a14 2
const error_html = '<doctype html><html><body><h1>Error rendering Pug template</h1><pre>

d40 1
a40 1
//                const error_html = '<doctype html><html><body><h1>Error rendering Pug template</h1><pre>${err.message}</pre></body></html>';
@


1.10
log
@(rcsvers.vim) modified outside of vim.
@
text
@d42 1
a42 1
                const error_html = '<doctype html><html><body><h1>Error rendering Pug template</h1><pre>${err.message}</body></html>';
@


1.9
log
@(rcsvers.vim) modified outside of vim.
@
text
@d42 1
a42 1
                const error_html = `<doctype html><html><body><h1>Error rendering Pug template</h1><pre>${err.message}</body></html>`;
@


1.8
log
@(rcsvers.vim) modified outside of vim.
@
text
@d15 3
a17 1
function pugpdf(options) {
d36 9
a44 3
            const html = pug.render(pugStr, options.locals);
            console.log('pugToHtml html:', html);
            this.push(html);
@


1.7
log
@(rcsvers.vim) modified outside of vim.
@
text
@d34 1
a34 1
            const html = pug.render(options.locals);
@


1.6
log
@(rcsvers.vim) modified outside of vim.
@
text
@d33 1
@


1.5
log
@(rcsvers.vim) modified outside of vim.
@
text
@d27 2
a28 1
            pugStr += chunk; // accumulate whole pug template
d32 3
a34 2
            var fn = pug.compile(pugStr);
            var html = fn(options.locals);
@


1.4
log
@(rcsvers.vim) modified outside of vim.
@
text
@d7 1
a7 1
    through = require('through'),
d25 4
a28 3
    var pugToHtml = through(
        function write(data) {
            pugStr += data; // accumulate whole pug template
d30 1
a30 1
        function end() {
d33 3
a35 2
            this.queue(html);
            this.queue(null);
d40 1
a40 1
    }
d42 2
a43 2
    const inputStream = through(),
        outputStream = through();
@


1.3
log
@(rcsvers.vim) modified outside of vim.
@
text
@a21 1
    options.renderDelay = options.renderDelay || 500;
d27 1
a27 1
            pugStr += data;
d36 3
d40 2
a41 2
    var inputStream = through()
        , outputStream = through();
d46 3
a48 1
        if (err) return outputStream.emit('error', err);
d52 3
a54 1
            if (err) return outputStream.emit('error', err);
a66 1
                    options.renderDelay,
d70 3
a72 1
                    if (err) return outputStream.emit('error', err);
@


1.2
log
@(rcsvers.vim) modified outside of vim.
@
text
@d1 2
a2 1
/* jshint node: true */
d16 56
a71 51
  options = options || {};
  options.phantomPath = options.phantomPath || require('phantomjs-prebuilt').path;
  options.cssPath = options.cssPath || __dirname + '/../pdf.css';
  options.paperFormat = options.paperFormat || 'A4';
  options.paperOrientation = options.paperOrientation || 'portrait';
  options.paperBorder = options.paperBorder || '1cm';
  options.renderDelay = options.renderDelay || 500;
  options.locals = options.locals || {};

  var pugStr = '';
  var pugToHtml = through(
    function write(data) {
      pugStr += data;
    }
  , function end() {
      var fn = pug.compile(pugStr);
      var html = fn(options.locals);
      this.queue(html);
      this.queue(null);
    }
  );

  var inputStream = through()
    , outputStream = through();

  inputStream.pause(); // until we are ready to read

  tmp.file({postfix: '.html'}, function(err, tmpHtmlPath, tmpHtmlFd) {
    if (err) return outputStream.emit('error', err);
    fs.close(tmpHtmlFd);

    tmp.file({postfix: '.pdf'}, function(err, tmpPdfPath, tmpPdfFd) {
      if (err) return outputStream.emit('error', err);
      fs.close(tmpPdfFd);

      var htmlToTmpHtmlFile = fs.createWriteStream(tmpHtmlPath);
      htmlToTmpHtmlFile.on('finish', function() {
        var args = [
          path.join(__dirname, '..', 'lib-phantom', 'index.js'),
          tmpHtmlPath,
          tmpPdfPath,
          options.cssPath,
          options.paperFormat,
          options.paperOrientation,
          options.paperBorder,
          options.renderDelay,
        ];

        childProcess.execFile(options.phantomPath, args, function(err, stdout, stderr) {
          if (err) return outputStream.emit('error', err);
          fs.createReadStream(tmpPdfPath).pipe(outputStream);
a72 4
      });

      inputStream.pipe(pugToHtml).pipe(htmlToTmpHtmlFile);
      inputStream.resume();
a73 1
  });
d75 1
a75 1
  return duplexer(inputStream, outputStream);
@


1.1
log
@vim
@
text
@d4 74
a77 1
module.exports = process.env.COVERAGE ? require('./lib-cov') : require('./lib');
@
